# -*- mode: python; -*-
#
# craftr_module(baremetal_hi)

from craftr import *
from craftr.ext import rules
from craftr.ext.compiler.gcc import GccCompiler
from craftr.ext.unix import Objcopy
from craftr.utils import prepend_path

prepend_path(path.expanduser('~/opt/bin'))

target = environ.get('TARGET', 'arm-eabi') + '-'
objcopy = Objcopy(target + 'objcopy')
gcc = ld = GccCompiler(target + 'gcc', language = None)
gcc = gcc.fork(
  defines = ['BmArm'],
  additional_flags = [
    '-mcpu=arm926ej-s', '-nodefaultlibs', '-nostdlib',
    '-nostartfiles', '-ffreestanding',
  ],
)


test = gcc.compile(
  sources = path.local('test.c'),
)

startup = gcc.compile(
  sources = [path.local('startup.S')],
  defines = ['RESET_ON_MAIN_COMPLETE'],
)

ld_script = rules.render_template(
  # We can not know the path to the object file generated from
  # startup.S until we created the target so we need to render
  # the filename into the linker script.
  output = 'link.ld',
  template = path.local('Craftr.link-template.ld'),

  # Variables to replace:
  STARTUP_OBJ = startup.outputs[0],
)

test_elf = ld.link(
  output = 'test.elf',
  linker_script = ld_script.outputs[0],

  # The object file generated from startup.S is listed in the
  # linker script already, we must not pass it as an input here
  # otherwise it would be used twice.
  inputs = [test],

  # That is why we add it only as an implicit dependency to the target.
) << startup


test_bin = objcopy.objcopy(
  inputs = [test_elf],
  output_format = 'binary',
)

run = rules.run(
  'qemu-system-arm', '-M', 'versatilepb', '-m', '128M', '-no-reboot', '-kernel', '$in', '-nographic',
  inputs = [test_bin],
)
